/* Generated by https://github.com/corsix/fast-crc32/ using: */
/* ./generate -i avx512_vpclmulqdq -p crc32c -a v4x2e */
/* MIT licensed */

#include <stddef.h>
#include <stdint.h>
#include <nmmintrin.h>
#include <immintrin.h>

#if defined(_MSC_VER)
#define CRC_AINLINE static __forceinline
#define CRC_ALIGN(n) __declspec(align(n))
#else
#define CRC_AINLINE static __inline __attribute__((always_inline))
#define CRC_ALIGN(n) __attribute__((aligned(n)))
#endif
#define CRC_EXPORT extern

#define clmul_lo(a, b) (_mm512_clmulepi64_epi128((a), (b), 0))
#define clmul_hi(a, b) (_mm512_clmulepi64_epi128((a), (b), 17))

uint32_t crc32_sse(uint32_t crc0, const uint8_t *data, size_t len);

uint32_t crc32_avx512_vpclmulqdq(uint32_t crc0, const uint8_t *data, size_t len)
{
  const char *buf = (const char *)data;

  crc0 = ~crc0;
  for (; len && ((uintptr_t)buf & 7); --len)
  {
    crc0 = _mm_crc32_u8(crc0, *buf++);
  }
  while (((uintptr_t)buf & 56) && len >= 8)
  {
    crc0 = _mm_crc32_u64(crc0, *(const uint64_t *)buf);
    buf += 8;
    len -= 8;
  }
  if (len >= 512)
  {
    const char *end = buf + len;
    const char *limit = buf + len - 512;
    __m128i z0;
    /* First vector chunk. */
    __m512i x0 = _mm512_loadu_si512((const void *)buf), y0;
    __m512i x1 = _mm512_loadu_si512((const void *)(buf + 64)), y1;
    __m512i x2 = _mm512_loadu_si512((const void *)(buf + 128)), y2;
    __m512i x3 = _mm512_loadu_si512((const void *)(buf + 192)), y3;
    __m512i k;
    k = _mm512_broadcast_i32x4(_mm_setr_epi32(0xdcb17aa4, 0, 0xb9e02b86, 0));
    x0 = _mm512_xor_si512(_mm512_castsi128_si512(_mm_cvtsi32_si128(crc0)), x0);
    y0 = clmul_lo(x0, k), x0 = clmul_hi(x0, k);
    y1 = clmul_lo(x1, k), x1 = clmul_hi(x1, k);
    y2 = clmul_lo(x2, k), x2 = clmul_hi(x2, k);
    y3 = clmul_lo(x3, k), x3 = clmul_hi(x3, k);
    x0 = _mm512_ternarylogic_epi64(x0, y0, _mm512_loadu_si512((const void *)(buf + 256)), 0x96);
    x1 = _mm512_ternarylogic_epi64(x1, y1, _mm512_loadu_si512((const void *)(buf + 320)), 0x96);
    x2 = _mm512_ternarylogic_epi64(x2, y2, _mm512_loadu_si512((const void *)(buf + 384)), 0x96);
    x3 = _mm512_ternarylogic_epi64(x3, y3, _mm512_loadu_si512((const void *)(buf + 448)), 0x96);
    buf += 512;
    /* Main loop. */
    while (buf <= limit)
    {
      y0 = clmul_lo(x0, k), x0 = clmul_hi(x0, k);
      y1 = clmul_lo(x1, k), x1 = clmul_hi(x1, k);
      y2 = clmul_lo(x2, k), x2 = clmul_hi(x2, k);
      y3 = clmul_lo(x3, k), x3 = clmul_hi(x3, k);
      x0 = _mm512_ternarylogic_epi64(x0, y0, _mm512_loadu_si512((const void *)buf), 0x96);
      x1 = _mm512_ternarylogic_epi64(x1, y1, _mm512_loadu_si512((const void *)(buf + 64)), 0x96);
      x2 = _mm512_ternarylogic_epi64(x2, y2, _mm512_loadu_si512((const void *)(buf + 128)), 0x96);
      x3 = _mm512_ternarylogic_epi64(x3, y3, _mm512_loadu_si512((const void *)(buf + 192)), 0x96);
      y0 = clmul_lo(x0, k), x0 = clmul_hi(x0, k);
      y1 = clmul_lo(x1, k), x1 = clmul_hi(x1, k);
      y2 = clmul_lo(x2, k), x2 = clmul_hi(x2, k);
      y3 = clmul_lo(x3, k), x3 = clmul_hi(x3, k);
      x0 = _mm512_ternarylogic_epi64(x0, y0, _mm512_loadu_si512((const void *)(buf + 256)), 0x96);
      x1 = _mm512_ternarylogic_epi64(x1, y1, _mm512_loadu_si512((const void *)(buf + 320)), 0x96);
      x2 = _mm512_ternarylogic_epi64(x2, y2, _mm512_loadu_si512((const void *)(buf + 384)), 0x96);
      x3 = _mm512_ternarylogic_epi64(x3, y3, _mm512_loadu_si512((const void *)(buf + 448)), 0x96);
      buf += 512;
    }
    /* Reduce x0 ... x3 to just x0. */
    k = _mm512_broadcast_i32x4(_mm_setr_epi32(0x740eef02, 0, 0x9e4addf8, 0));
    y0 = clmul_lo(x0, k), x0 = clmul_hi(x0, k);
    y2 = clmul_lo(x2, k), x2 = clmul_hi(x2, k);
    x0 = _mm512_ternarylogic_epi64(x0, y0, x1, 0x96);
    x2 = _mm512_ternarylogic_epi64(x2, y2, x3, 0x96);
    k = _mm512_broadcast_i32x4(_mm_setr_epi32(0x6992cea2, 0, 0x0d3b6092, 0));
    y0 = clmul_lo(x0, k), x0 = clmul_hi(x0, k);
    x0 = _mm512_ternarylogic_epi64(x0, y0, x2, 0x96);
    /* Reduce 512 bits to 128 bits. */
    k = _mm512_setr_epi32(0x1c291d04, 0, 0xddc0152b, 0, 0x3da6d0cb, 0, 0xba4fc28e, 0, 0xf20c0dfe, 0, 0x493c7d27, 0, 0, 0, 0, 0);
    y0 = clmul_lo(x0, k), k = clmul_hi(x0, k);
    y0 = _mm512_xor_si512(y0, k);
    z0 = _mm_ternarylogic_epi64(_mm512_castsi512_si128(y0), _mm512_extracti32x4_epi32(y0, 1), _mm512_extracti32x4_epi32(y0, 2), 0x96);
    z0 = _mm_xor_si128(z0, _mm512_extracti32x4_epi32(x0, 3));
    /* Reduce 128 bits to 32 bits, and multiply by x^32. */
    crc0 = _mm_crc32_u64(0, _mm_extract_epi64(z0, 0));
    crc0 = _mm_crc32_u64(crc0, _mm_extract_epi64(z0, 1));
    len = end - buf;
  }
  for (; len >= 8; buf += 8, len -= 8)
  {
    crc0 = _mm_crc32_u64(crc0, *(const uint64_t *)buf);
  }
  for (; len; --len)
  {
    crc0 = _mm_crc32_u8(crc0, *buf++);
  }
  return ~crc0;
}
